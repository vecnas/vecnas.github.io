<h4>Анализ ошибок</h4>
Некоторые ошибки являются типовыми, из разряда как в Spring разработчик забывает отметить компонент инъектируемым.
В настоящее время две ошибки можно выделить как типовые (или может правильно сказать - две разновидности одной).

<h4>Возвращаемое значений функций XL</h4>
Функции XL как правило возвращают функции, требующие вызова, либо некое API к декларируемому поведению
(по сути дела когда возвращается одна функция - это и есть упрощенное API с одним методом запуска).
Нередко можно забыть об этом и считать что одного вызова достаточно, в этом случае внешний симптом "оно ничего не делает":
<pre><code class="js">
  jiant.xl.statefulApp(app, "View", app.states.main)
</code></pre>
- ничего еще не произошло, т.к. возвращаемая функция запуска не была вызвана
<pre><code class="js">
  jiant.xl.statefulApp(app, "View", app.states.main)<b>()</b>
</code></pre>
- все выполнилось как задумано.
<p></p>
Чтобы точно знать как использовать данную XL функцию - посмотрите <a href="#jDocs=,xl,xl0,0,">документацию</a> к ней.

<h4>Использование несвязанных объявлений</h4>
Проявляется как "что-то не работает" - например, в модуле объявлен виджет и обращения к его полям ничего не делают
или генерируют ошибки типа "нет такого метода".
<p></p>
Другой вариант - неработающая модель. Методы есть, но при вызове ничего не происходит.
<p></p>
Причина в том что эти объекты не связаны. Они объявлены выше в самом модуле, но для них не выполнена реализация.
Возможно, они даже работали раньше, а после рефакторинга перестали. Например, модуль мог ранее грузиться как часть приложения,
из секции <b>modules</b>, а сейчас грузится вызовом <b>loadModule</b> в более позднее время.
<p></p>
Либо обращение происходит до вызова метода <b>jiant.onApp</b>.
<p></p>
<b>Решение</b> в том, чтобы связать эти объекты. Необходимо понять какой из двух вариантов имеет место быть:
<ul>
  <li>Обращение к объекту происходит за пределами <b>jiant.onApp</b>. В этом случае нужно перенести его в коллбэк данного метода
<pre><code class="js">
jiant.module("myModule", function($, app) {
    <strike>app.models.user.firstName();</strike>
    jiant.onApp(app, function() {
        <b>app.models.user.firstName();</b>
    });
});
</code></pre>
  </li>
  <li>Модуль загружен посредством <b>jiant.loadModule</b>. В этом случае нужно выполнить связывание объектов, например
    <b>jiant.bindModel</b>.
    <pre><code class="js">
jiant.module("myModule", function($, app) {
    jiant.onApp(app, function() {
        <strike>app.models.user.firstName();</strike>
        <b>const model = jiant.bindModel("user", {...});</b>
        app.models.user.firstName();
    });
});
</code></pre>

  </li>
</ul>

<h4>Вопросы про ajax</h4>
Случай из жизни, демонстрирующий реализацию ajax секции.
<pre>
app.ajax.getData = function (type, cb) {};
app.ajax.test = function (type, cb) {};
app.ajax.searchUsers = function(type) {}

app.ajax.searchUsers(312322);
app.ajax.getData(312322);
app.ajax.test(312322);

https://www.***.ru/getData?type=312322&antiCache3721=1610448890317
https://www.***.ru/searchUsers?antiCache3721=1610448890329
https://www.***.ru/test/?type=312322&antiCache3721=1610448890324

3 одинаковые функции, 3 одинаковых вызова и три разных урл - как так?
</pre>

Что можно сказать по этому поводу:
<ol>
  <li>
    Запрос идет на урл, равный имени объявленной функции, а не правой части. Т.е. все три функции названы по разному и имеют три разных целевых урла.
  </li>
  <li>
    В объявлении <b>searchUsers</b> мы видим только один аргумент - <b>type</b>. Он первый и последний, а последний аргумент
    всегда считается коллбэком вызова. Т.е. функция объявлена как запрос без аргументов, с коллбэком <b>type</b>.
    Чтобы получить желаемое поведение - нужно добавить еще один аргумент в конце и сигнатура будет <b>function (type, cb)</b>
  </li>
  <li>Самое любопытное это как функция <b>test</b> превратилась в запрос <b>test/</b>?
    Просмотр закладки network выявил что это редирект сервера, который таким образом подменял не найденные урлы.
    Напоминание - недостаточно смотреть отладочную печать в консоли, обязательно заглядывайте и на панель запросов сети.</li>
</ol>