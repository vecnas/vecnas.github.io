<h4>Внутренняя архитектура</h4>

Как любое удачное решение, jiant использует свой же функционал для собственных целей.

<h4>Модули</h4>

Jiant разбит на модули. Базовый функционал содержит только механизм работы с модулями, объявления типов элементов и функции типа <b>app</b>, <b>onApp</b>.
В зависимости от содержимого переменной определения приложения, остальные функции догружаются как модули.
Например, если присутствует секция <b>models</b>, грузится модуль <b>jiant-models</b>
<pre><code class="js">
jiant.module("jiant-models", ["jiant-util"], function($, app, jiant, params, Util) {

  this.singleton();

  ...
</code></pre>

Таким образом весь функционал jiant разбит на модули. При анализе переменной определения приложения
создается внутреннее приложение загрузчика, которое содержит только необходимые модули jiant, грузится как стандартное
jiant приложение, и затем грузит уже пользовательское приложение.

<p></p>

Как следствие, для загрузки используя методы <b>bindModel</b>, <b>bindTemplate</b>, и другие - соответствующую секцию необходимо
объявить хотя бы пустой в определении приложения, чтобы загрузчик был доступен.

<h4>Переопределение модуля</h4>
В случае если модуль уже имеется - новый не грузится, что позволяет "переопределять" модули. Например, в базовой
поставке один из модулей содержит дефект, у разработчика есть исправленный локально вариант. Тогда можно вначале
предоставить Jiant'у исправленный вариант и работать с ним, пока не будет исправлена базовая поставка.

<h4>Этапы жизненного цикла</h4>
Последовательность загрузки/исполнения кода при вызове <b>jiant.onApp</b>:
<ol>
  <li>Чтение переменной определения приложения, составляется список необходимых компонентов jiant</li>
  <li>Создается переменная приложения-загрузчика, со списком необходимых модулей jiant</li>
  <li>После загрузки загрузчика - он загружает само пользовательское приложение: <ol>
    <li>Читает секцию <b>modules</b> и загружает все модули</li>
    <li>Когда все модули загружены - они исполняются, исходя из заданного порядка</li>
    <li>Во время исполнения модуля - все объявленные в нем виджеты, шаблоны, модели и прочее - добавляются в структуру
      определения приложения</li>
    <li>Во время исполнения модуля - сохраняются все объявленные в <b>jiant.onApp</b> коллбэки</li>
    <li>После исполнения всех модулей - выполняется связывание всех объявлений в дереве приложения</li>
    <li>Активируется событие и срабатывают все объявленные в <b>jiant.onApp</b> коллбэки</li>
  </ol></li>
</ol>

После связывания вызовы <b>loadModule</b> немедленно ставятся на исполнение,
включая выполнение кода модуля и <b>jiant.onApp</b> коллбэк, если он объявлен.

<h4>Модели</h4>
Для каждой модели создается прототип объектов и коллекций этой модели.
<p></p>
При объявлении метода модели <b>jRepo.findBy</b> или <b>jRepo.listBy</b> - автоматически создается индекс,
поэтому скорость работы этих методов практически мгновенная.

<h4>Локализация</h4>
Рекомендуется пользоваться локализацией <b>i18next</b>. Для ее работы необходимо подключить эту библиотеку,
одна из ее версий есть в репозитории jiant: <b>i18next-1.7.5.min.js</b>.

<h4>Состояния</h4>
Для работы с состояниями необходимо подключать небольшой плагин jquery, его версия есть в репозитории: <b>jquery.hashchange.js</b>

<h4>jQuery</h4>
Виджеты, шаблоны и их элементы представляют собой jQuery wrapper объекты и соответственно предоставляют полный набор jQuery функциональности.

<h4>Исходный код</h4>
Находится по адресу <a href="https://github.com/vecnas/jiant">https://github.com/vecnas/jiant</a>