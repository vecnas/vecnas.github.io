<h4>Программная логика</h4>

Иногда необходимо чтобы программная логика могла быть переиспользована по всему приложению.
Для таких случаев Jiant предлагает абстракцию программной логики.
<p></p>
Объявите раздел <b>logic</b> в спецификации приложения

<pre><code class="js">
    logic: {
        verifier: {
            checkField: function(field) {}
        },
        dataProcessor: {
            processData: function(data) {},
            processData2: function(data, anotherParam) {}
        }
    }
</code></pre>

раздел содержит набор интерфейсов, каждый содержит одну или несколько пустых функций.
Эти интерфейсы есть абстракции программной логики.

<h4>Реализация</h4>

Во время связывания приложения каждая логика получает метод <b>implement()</b>, принимающий реализацию.
Теперь, если какой-то код реализует данную логику, он выполняет этот метод, передавая объект реализации:

<pre><code class="js">
    jiant.onUiBound(app, function($, app) {
        app.logic.verifier.implement({
            checkField: function(field) {
                // собственно реализация
            }
        });
    });
</code></pre>
Также можно вызвать метод <b>jiant.implement</b>
<pre><code class="js">
    jiant.onUiBound(app, function($, app) {
        jiant.implement(app.logic.verifier, {
            checkField: function(field) {
                // собственно реализация
            }
        });
    });
</code></pre>

<h4>Использование</h4>

Если какой-то код использует логику, он ее просто использует:
<pre><code class="js">
    app.logic.verifier.checkField(fld);
</code></pre>

Однако, что если реализация еще не загружена. Это возможно при использовании минификации кода,
когда порядок исполнения скриптов изменен, а также если реализация подгружается отдельным файлом.
<p></p>
Чтобы избежать подобных проблем - достаточно объявить зависимость от логики
во время вызова <b>onUiBound()</b>:

<pre><code class="js">
    jiant.onUiBound(app, ["verifier"], function($, app) {});
</code></pre>

И этот код исполнится только после того как логика <b>verifier</b> будет реализована.

<h4>Обработка ошибок</h4>

Jiant поддерживает цепочки зависимостей логик, но некоторые могут привести к тупику
из-за взаимной зависимости и зацикленности, если не быть аккуратным.
<p></p>
Например, код реализует логику А и зависит от Б, а другой код
реализует Б, но зависит от А.
<p></p>
Jiant предлагает 2 инструмента для того чтобы разработчик мог обнаружить такие проблемы:
<ul>
    <li><b>jiant.getAwaitingDepends()</b> функция возвращает список всех нереализованных
        логик на текущий момент, просто вызовите ее в консоли
    </li>
    <li>включите DEV_MODE, тогда если в течение 10 секунд после связывания приложения
        останутся нереализованные логики - ошибка будет напечата в консоль
    </li>
</ul>

Также во время выполнения <b>implement()</b> jiant проверяет что все объявленные методы реализованы
и печатает в консоль сообщения об отсутствующих.

<h4>Внешние модули</h4>

Когда программная логика не зависит от конкретного приложения и может использоваться в разных -
используйте внешние модули.
<p></p>
Сделайте вызов в виде:

<pre><code class="js">
    jiant.declare("logicName", {
        verify: function(fld) {
            // собственно реализация
        }
    })
</code></pre>

и все зависимости от <b>logicName</b> будут разрешены. Если на странице несколько приложений
и только некоторые используют эту логику - она будет загружена только для них. Не следует хранить
специфичные для приложения данные внутри внешнего модуля, так как он может использоваться
одновременно для нескольких приложений.
<p></p>
Также declare можно использовать с урлом в качестве второго параметра:
<pre><code class="js">
  jiant.declare("extLibLocal", "anonym.js");
</code></pre>
После загрузки скрипта зависимость будет разрешена, далее на совести автора что сделает загруженный скрипт
(как правило, ожидается что в нем будет вызван код, реализующий данную логику,
либо не будет прямых обращений к данной логике как API).

<pre><code class="js">
jiant.declare("extLibLocal", "anonym.js");

jiant.declare("extLib", "https://raw.githubusercontent.com/vecnas/jiant/master/usage_example/anonym.js");
jiant.declare("extLibLocal2", "anonym.js");
jiant.declare("googleConversion", "http://www.googleadservices.com/pagead/conversion.js");

jiant.bindUi({id:"id"});

jiant.onUiBound("id", ["extLib", "extLibLocal", "extLibLocal2", "googleConversion"], function($, app) {
    alert("loaded extLibExternal");
    jiant.bindUi({id:"id2"});
    jiant.onUiBound("id2", ["extLib", "extLibLocal", "extLibLocal2", "googleConversion"], function($, app) {
        alert("loaded extLibAInternal");
    });
});
</code></pre>
В данном случае загружаются внешние библиотеки

<h4>Переопределение функций</h4>
Если возникает необходимость использовать какую-то реализацию набора функций, но при этом одну или несколько
из них нужно заменить на свои, можно использовать <b>override(spec, implFn)</b>, этот метод принимает два параметра,
ссылку на спецификацию логики и функцию которая возвращает переопределенные методы. Этот метод необходимо вызывать
до того как будет вызван <b>implement()</b>, чтобы во время вызова implement и последующих, зависящих
от логики участков кода, использовался переопределенный метод
<pre><code class="js">
  jiant.override(app.logic.api, function($, app) {
//      var prevTest = app.logic.api.test;
      return {
          test: function() {
//          prevTest();
          jiant.logInfo("overriden", this);
      }
    }
  });
</code></pre>


<h4>Пример</h4>

Рассмотрим менеджер диалогов, которые могут показываться различными способами, в зависимости от окружения -
boostrap, jquery-ui, modalPopup. Мы можем обеспечить все три реализации логики "dialogs" и использовать нужную
