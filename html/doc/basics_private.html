<h4>Приватные и публичные</h4>
Jiant позволяет создавать публично доступные объекты (виджеты, шаблоны, события, вызовы аякса и тд), и приватные, доступные только в рамках заданного кода.

<h4>Публичные объекты</h4>
Любые объекты, объявленные или добавленные в дерево приложения, являются доступными для любого кода приложения. Например, все шаблоны из секции <b>app.templates</b>:
<pre><code class="js">
  const app = {
      id: ...,
      templates: {
          campaignRowTm: {},
          userIconTm: {}
      }
  }

  jiant.app(app);
</code></pre>
Эти объекты создаются во время начального связывания приложения, или же могут быть добавлены в любой момент.

<h4>Приватные объекты</h4>
Как правило, такие объекты создаются в рамках некоего модуля, который требует их наличие для своей полноценной работы.
Данные объекты не объявляются как часть файла приложения, а создаются посредством вызова функций jiant.bindXXX (см. далее для деталей).
Например, в рамках некоего модуля:
<pre><code class="js">
  jiant.module("myModule", function($, app, jiant) {
      jiant.onApp(app, function() {
          const myView = jiant.bindView(app, "myView", {label: jiant.label, button: jiant.ctl});
          myView.button.click(function() {...});
      });
  });
</code></pre>
Вопрос - в какую секцию поместить данное объявление, в сам модуль или в <b>jiant.onApp</b>. Как правило, особой разницы нет.
Но для общности стиля кода, лучше помещать в <b>onApp</b>. Это также защитит от незапланированного времени использования модуля
(например, если вместо его динамической загрузки посредством <b>loadModule</b>, модуль будет грузиться через секцию <b>modules</b> приложения)
<p></p>
После создания этот объект не будет помещен в дерево приложения и ссылка на него будет только у создающего кода.
<p></p>
Для приватных объектов работают все механизмы, такие как подписки на изменения, propagate в обе стороны и прочее.

<h4>Используемый функционал исходного приложения</h4>
Если планируется, например, создавать только приватные объекты - все-равно следует добавить в приложение соответствующие глобальные секции, например:
<pre><code class="js">
    const app = {
        templates: {},
        states: {},
        models: {}
    }
</code></pre>

Это гарантирует предзагрузку соответствующих компонентов jiant (например, отвечающих за работу с состояниями).
Иначе при вызове <b>jiant.bindState</b> может произойти ошибка

<h4>Компоненты</h4>
Компоненты,  используемые как <b>jiant.comp</b>, могут быть только публичными. Это требование следует из их природы - переиспользуемые в разных местах кода компоненты.
Для приватных шаблонов у вас просто не будет идентификатора чтобы на него сослаться.

<h4>Методы связывания</h4>
Следующие методы сейчас доступны для создания приватных объектов, некоторые включат имена для простоты идентификации при анализе кода.
Каждый метод возвращает реализацию объекта и также расширяет спецификацию объекта на его реализацию.

<table class="defTable">
  <tr>
    <td>bindView (appRoot, viewId, viewContent, viewImpl)</td>
    <td>Создает реализацию виджета, выполняя все проверки объявленных элементов. Чтобы сделать публичным
      - достаточно поместить в дерево приложения.
      Если уже есть публичный виджет с таким идентификатором - он будет обновлен результатом данного вызова.
      См. также секцию <a href="#jDocs=,views,views0,14,">Связывание отдельного виджета</a>.
    Параметры: <ol>
        <li><b>appRoot</b> - определение приложения (при этом сам виджет не будет добавлен в это определение)</li>
        <li><b>viewId</b> - идентификатор виджета, носит документативный характер</li>
        <li><b>viewContent</b> - определение виджета, аналогично <a href="#jDocs=,views,views0,1,">Объявлению виджетов</a></li>
        <li><b>viewImpl</b> - опциональный параметр. Ссылка на jquery wrapper объект, используемый для реализации.
          При отсутствии - реализация подбирается автоматически исходя из текущей UiFactory</li>
      </ol>
<pre><code class="js">
    const view = {
        email: jiant.input,
        name: jiant.label
    };
    jiant.onApp("myApp", function($, app) {
        const boundView = jiant.bindView(app, "myView", view);
    });
</code></pre>
    </td>
  </tr>
  <tr>
    <td>bindTemplate (appRoot, tmId, tmContent, tm)</td>
    <td>Связывает шаблон с реализацией выполняя все проверки объявленных элементов.
      Если шаблон планируется к использованию как компонент - его необходимо добавить в секцию <b>templates</b> определения приложения.
      Параметры: <ol>
        <li><b>appRoot</b> - определение приложения (при этом сам шаблон не будет добавлен в это определение)</li>
        <li><b>tmId</b> - идентификатор шаблона, носит документативный характер</li>
        <li><b>tmContent</b> - определение шаблона, аналогично <a href="#jDocs=,views,views0,1,">Объявлению виджетов</a></li>
        <li><b>tm</b> - опциональный параметр. Ссылка на jquery wrapper объект, используемый для реализации.
          При отсутствии - реализация подбирается автоматически исходя из текущей UiFactory</li>
      </ol></td>
  </tr>
  <tr>
    <td>bindState (appRoot, name, stateSpec)</td>
    <td>Добавляет отслеживаемое состояние приложения, см. секцию про <a href="#jDocs=,states,states0,0,">состояния</a>
      Параметры: <ol>
        <li><b>appRoot</b> - определение приложения (при этом само состояние не будет добавлено в это определение)</li>
        <li><b>name</b> - идентификатор состояния, должен быть уникален в рамках приложения</li>
        <li><b>stateSpec</b> - определение состояния, см. <a href="#jDocs=,states,states0,0,">состояния</a></li>
      </ol>
<pre><code class="js">
    const state = jiant.bindState(app, "myState", {go: function(myData) {}});
    ...
    state.go("my local data");
</code></pre>
    </td>
  </tr>
  <tr>
    <td>bindEvent (spec)</td>
    <td>Реализует событие event bus, см. секцию про <a href="#jDocs=,events,events0,0,">события</a> для деталей спецификации
<pre><code class="js">
    const event = jiant.bindEvent({
        fire: function(data),
        on: function(cb)
      });
    ...
    event.fire(myData);
</code></pre>
    </td>
  </tr>
  <tr>
    <td>bindSemaphore (spec)</td>
    <td>Реализует семафор, см. секцию про <a href="#jDocs=,semaphores,semaphores0,0,">семафоры</a> для деталей спецификации
      <pre><code class="js">
    const sem = jiant.bindSemaphore({
        release: function(data),
        on: function(cb)
      });
    ...
    sem.release(myData);
</code></pre>
    </td>
  </tr>
  <tr>
    <td>bindModel (modelName, spec)</td>
    <td>Реализует модель, см. также <a href="#jDocs=,models,models0,1,">Связывание отдельной модели</a>
      Параметры: <ol>
        <li><b>modelName</b> - уникальное наименование модели</li>
        <li><b>spec</b> - определение модели, см. <a href="#jDocs=,models,models0,0,">Модели данных</a></li>
      </ol>
<pre><code class="js">
    const privateModel = jiant.bindModel("env", {
                jRepo: {},
                filter: function(val) {},
                pageNum: function(val) {}
            });
</code></pre>
    </td>
  </tr>
  <tr>
    <td>bindAjax (name, funcSpec, appRoot)</td>
    <td>Реализует серверный вызов, возвращает соответствующую функцию
      Параметры: <ol>
        <li><b>name</b> - уникальное наименование функции</li>
        <li><b>funcSpec</b> - определение серверного вызова, см. <a href="#jDocs=,ajax,ajax0,0,">Серверные вызовы</a></li>
        <li><b>appRoot</b> - определение приложения (при этом сама функция не будет добавлена в это определение)</li>
      </ol>

      <pre><code class="js">
    const getServerData = jiant.bindAjax("getServerData", function(userId, cb) {}, app);
    ...
    getServerData(userId, callback);
</code></pre>
    </td>
  </tr>
  <tr>
    <td>bindTree (appRoot, tree)</td>
    <td>Реализует переданное дерево объектов <b>tree</b> согласно настройкам переданного приложения <b>appRoot</b>.
      Данный метод необходимо вызывать только после связывания приложения.
<pre><code class="js">
    jiant.module("tree", function($, app) {
        jiant.onApp(app, function() {
            const tree = jiant.bindTree(app, {
                templates: {
                    localTm: {...}
                },
                models: {
                    privateModel: {...}
                }
            });
        });
</code></pre>
    </td>
  </tr>
</table>