<h4>Модули</h4>

Модульная организация javascript кода предоставляет ряд удобств. На сегодняшний день уже существует набор
стандартных решений, типа ECMA 6 модули или requirejs. На практике каждое из них имеет свои плюсы и минусы.
<p></p>
Jiant также предоставляет несложный механизм модуляризации приложений, разработанный на основе собственного опыта
разработки приложений.
Чтобы использовать модули, добавьте секцию <b>modules</b> в спецификацию приложения

<pre class="brush: js">
    modulesPrefix: "modules/",
    modules: {
        ["docsMain", "toolbarHandler", "extraLogic"],
    }
</pre>
Соответствующие модули будут загружены для данного приложения, используя заданные настройки.

<h4>Конфигурация секции</h4>
Параметр спецификации <b>modulesPrefix</b> задает префикс пути для загрузки всех модулей, параметр необязательный.
Секция модулей может задаваться массивом либо ассоциативным массивом, оба варианта валидные
<pre class="brush: js">
    modulesPrefix: "modules/",
    modules: {
        ["docsMain", "toolbarHandler", "extraLogic"],
    }
  // -----------------------
  modules: {
      "m1": "m1"
  }
</pre>

При объявлении модулей можно использовать объекты, в этом случае ключ служит префиксом пути
<pre class="brush: js">
  modules: ["stripAnimation",
    {"shared": ["dialogs", "cellsMath", "positioner", "graphics"]},
    {"app3d" : ["utils", "shaders", "driver3"]}
  ]
</pre>
В данном объявлении грузятся модули из трех локаций:
<ul>
  <li>
    <b>базовая папка</b> - stripAnimation файл, содержащий одноименный модуль (<b>/stripAnimation.js</b>)
  </li>
  <li>
    <b>shared</b> - подпапка shared под рутовой папкой, заданной настройкой modulesPrefix (<b>/shared/dialogs.js</b>)
  </li>
  <li>
    <b>app3d</b> - подпапка app3d (<b>/app3d/utils.js</b>)
  </li>
</ul>

<h4>Полная конфигурация модуля</h4>
При объявлении секции модулей приложения, следующие настройки могут быть заданы
<pre class="brush: js">
  modules: [
      "mods": [
          {"m1" : {
                  order: 30,
                  name: "m1",
                  path: "modules/m1",
                  val: "some module value"
              }
          }, "m2", "m1z"]
</pre>
Все настройки не обязательные
<ul>
  <li>
    <b>order</b> задает порядок загрузки модуля. Все модули выстраиваются в порядке возрастания order
    и выполняются последовательно. По умолчанию это порядок в котором модули перечислены
  </li>
  <li>
    <b>name</b> - имя модуля для загрузки, это имя должно соответствовать имени модуля в объявлении <b>jiant.module</b>,
    описанном ниже. По умолчанию равно ключу
  </li>
  <li>
    <b>path</b> - путь к джаваскрипт файлу. Если модуль уже есть в наличии, этот путь игнорируется.
    По умолчанию равен имени модуля. К этому пути добавляется префикс, если это возможно.
  </li>
  <li>
    <b>val</b> - параметр модуля, смотрите описание модуля. Количество параметров не ограничено
  </li>
</ul>

<h4>Объявление модуля</h4>
Отдельный модуль создается вызовом <b>jiant.module</b>
<pre class="brush: js">
  jiant.module("m1", ["m3"], function ($, app, jiant, params, m3) {
  .....
  jiant.module("m1", function ($, app) {
  .....
</pre>
Как правило он расположен в отдельном файле с тем же именем что модуль. Если имя модуля не совпадает с именем файла,
необходимо указать имя в спецификации модулей приложения через параметр <b>name</b>. Параметры функции <b>jiant.module</b>
<ul>
  <li>
    <b>"m1"</b> - имя модуля, обязательно
  </li>
  <li>
    <b>["m3"]</b> - зависимости модуля, не обязательно
  </li>
  <li>
    <b>function ($, app, jiant, params, m3)</b> - функция, определяющая модуль, ниже описана подробно
  </li>
</ul>
Если модуль уже объявлен в коде, он не будет загружаться из файла, а сразу браться jiant'ом там где он используется.
Это полезно например при минификации, когда все модули собраны в один файл.

<h4>Имя модуля</h4>
Если имя модуля не соответствует имени, объявленному в спецификации, jiant считает что нужный модуль не загружен
и выдаст соответствующее сообщение об ошибке. По умолчанию имя модуля равно имени файла, но технически можно задавать
разные имена используя параметр <b>name</b>

<h4>Зависимости модуля</h4>
Некоторые модули могут зависеть от других, в этом случае зависимости перечисляются вторым параметром при вызове
функции <b>jiant.module</b>. Это должен быть массив, в остальном возможности в точности те же что при объявлении
модулей приложения, включая подпапки и полное описание
<pre class="brush: js">
  jiant.module("camera3d", [
      {"../shared": ["queue"]}
  ], function($, app, jiant, params, Queue) {
  .....
  jiant.module("driver3",
      ["gridRender", "visibleItems3d", "utils"],
      function($, app, jiant, params, gridRender, visibleItems3d, utils) {
  .....
</pre>
Если модуль с одним именем объявлен в зависимостях и в спецификации приложения, берутся настройки из спецификации.
Если модуль объявлен в нескольких зависимостях, берутся настройки из первого попавшегося места.
Если модуль уже есть в наличии, он используется (например, объявлен в теле базового файла скрипта)

<h4>Функция определения модуля</h4>
Третий параметр <b>jiant.module</b> это функция, выполнение которой означает загрузку модуля.
Также для модулей, предоставляющих какой-либо сервис, эта функция должна возвращать объект сервиса.
Функция получает следующие параметры при вызове:
<ul>
  <li>
    <b>$</b> - объект jQuery
  </li>
  <li>
    <b>app</b> - ссылка на спецификацию приложения
  </li>
  <li>
    <b>jiant</b> - ссылка на jiant
  </li>
  <li>
    <b>params</b> - параметры модуля, сконфигурированные в объявлении приложения
  </li>
  <li>
    <b>список зависимостей модуля</b> - для каждого модуля от которого зависит данный - передается
    дополнительный параметр, ссылающийся на объект сервиса модуля (объект, который вернула функция данного модуля).
    Это может быть <b>undefined</b>, если функция модуля ничего не возвращает
  </li>
</ul>

<h4>Минификация</h4>
Jiant модули полностью совместимы с минификацией без каких-либо усилий со стороны разработчика.
В этом случае все они загружаются через <b>jiant.module</b> и затем доступны при выполнении приложения.

<h4>Порядок загрузки и bindUi</h4>
Загрузка модулей происходит до выполнения bindUi (технически - на его первой фазе), поэтому приложение в этот момент
еще не доступно. Поэтому необходимо работающий с приложением код заключать в <b>onUiBound</b>.
Также возможно модифицировать приложение из модуля, и эти модификации будут применены к связыванию
<pre class="brush: js">
  jiant.module("m0", function ($, app) {

    var view = app.views.view = {
            ctlForget: jiant.ctl,
            ctlBind: jiant.ctl,
            container: jiant.container,
            appPrefix: "",
            impl: '<div id="view"><button class="ctlForget">forget</button><button class="ctlBind">bind</button><div class="container"></div></div>'
        },
        tm = app.templates.tm = {
            name: jiant.label,
            impl: '<b id="_tm"><b class="_name"></b></b>'
        },
        m = app.models.test = {
            jRepo: {},
            func: function(val) {}
        };

    jiant.onUiBound(app, function ($, app) {
        $("body").append(view);
        view.ctlForget.click(function () {
            view.container.append(app.templates.tm.parseTemplate({name: new Date()}));
        });
        view.ctlBind.click(function () {
            jiant.bindUi("_", moduleApp, true);
        });
    });
</pre>
