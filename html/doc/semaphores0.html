<h4>Семафоры</h4>

В случае когда нужны некие флаги уровня приложения, возможно использовать семафоры.
Например, приложение грузит некие критические данные, без которых вся его работа невозможна.
Для использования семафоров - добавьте секцию <b>semaphores</b> в определение приложения:

<pre><code class="js">
    const myApp = {

        .....

        semaphores: {

            userLogged: {
                release: function(user) {},
                on: function(cb) {}
            },

            libDataLoaded: {
                release: function(libData) {},
                on: function(cb) {}
            }

        }
    }

</code></pre>

во время биндинга приложения методы <b>release</b> и <b>on</b> будут автоматически реализованы Jiant'ом.
Семафоры похожи на события, с той разницей, что они сохраняют свое состояние и данные и при последующих вызовах.
Они ведут себя как модели данных, но имеют более адаптированный к конкретным задачам интерфейс.

<h4>Сброс семафора</h4>

Чтобы отпустить семафор, в блоке <b>onApp</b> вызовите <b>release</b>:
<pre><code class="js">

  myApp.semaphores.userLogged.release({userName: "smith"});

  myApp.ajax.getLibData(function(libData) {
      myApp.semaphores.libDataLoaded.release(libData);
  })

</code></pre>

<ul>
  <li>Данные, переданные при сбросе семафора, запоминаются и передаются всем кто подписывается на него как до сброса, так и после</li>
  <li>Семафор может быть сброшен только один раз, последующие вызовы игнорируются</li>
</ul>


<h4>Подписка на семафор</h4>

Где-нибудь в блоке <b>onApp</b>, подпишитесь через метод <b>on</b>:

<pre><code class="js">
    myApp.semaphores.userLogged.on(function(user) {
        //обрабатываем данные
    });
</code></pre>

Если семафор уже сброшен - этот код выполнится немедленно, если еще нет - будет ожидать когда кто-нибудь вызовет <b>release</b>.

<h4>Передача данных</h4>

Коллбэк метода <b>on</b> получает в точности все аргументы, переданные в метод <b>release</b>.
Набор данных не зависит от объявленной сигнатуры метода <b>release</b> и зависит только от переданных аргументов во время вызова.
Данные запоминаются при вызове <b>release</b> и в дальнейшем передаются всем последующим вызовам <b>on</b>.

<h4>Для ленивых</h4>

методы <b>release</b> и <b>on</b> нужно определять только для целей автозавершения, документации и удобства.
Они всегда добавляются в семафор, независимо от объявления.
Кратчайшая работающая форма описания семафоров следующая:

<pre><code class="js">
    const myApp = {

        semaphores: {
            userLogged: {},
            libDataLoaded: {}
        }

    }
</code></pre>

Однако не рекомендуется так писать, потому что неясно какие именно данные содержатся в семафоре.

<h4>Приватные реализации</h4>
При связывании в рамках дерева, доступ к семафорам имеет весь код приложения.
Если семафор где-то используется локально, его можно объявить и реализовать приватно.
Подробности <a href="#jDocs=,basics,basics_private,0,">здесь</a>.
В этом случае код отдельного модуля может вызвать метод <b>jiant.bindSemaphore</b>, как в примере кода:
<pre><code class="js">
    const sem = jiant.bindSemaphore({
        release: function(data),
        on: function(cb)
      });
    ...
    sem.release(myData);
</code></pre>
Реализованный метод готов к использованию после данного вызова, но не доступен из дерева приложения.
Для использования приватной реализации, необходимо добавить секцию semaphores в дерево приложения, хотя бы пустую.
Пояснение <a href="#jDocs=,advanced,advanced_internal,0,">здесь</a>
