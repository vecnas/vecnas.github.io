<h4>Шаблоны</h4>

Шаблоны используются для генерации и показа повторяющегося содержимого на экране. 
Они предоставляют возможность привязки к данным с автоматическим обновлением при изменении базовых данных.
Чтобы использовать шаблоны, добавьте секцию <b>templates</b> в определение приложения:

<pre><code class="js">
    var app = {
        templates: {
            tmTagView: {},
            tmMenuItem: {}
        }
    }

    jiant.app(app);
</code></pre>

используем:

<pre><code class="js">
    app.templates.tmTagView.parseTemplate({text: "some text"});
</code></pre>


<h4>parseTemplate</h4>
Каждый шаблон получает функцию
<pre><code class="js">
    parseTemplate = function(data, subscribeForUpdates, reverseBind, mapping)
</code></pre>
вызов этой функции генерирует новый объект на базе данного шаблона. Этот объект может быть добавлен в ДОМ страницы
и обладает всеми возможностями виджетов. Параметры функции
<ul>
    <li><b>data</b> - данные для подстановки или привязки в шаблон, может быть простой объект или объект модели
    </li>
    <li><b>subscribeForUpdates</b> - только для моделей - нужно ли подписывать шаблон на изменения базового
        объекта модели, то же самое что в методе виджета propagate
    </li>
    <li><b>reverseBind</b> - только для моделей - нужно ли подписывать модель на изменения данных на интерфейсе,
        то же самое что в методе виджета propagate
    </li>
    <li><b>mapping</b> - то же самое что в методе виджета propagate, задает маппинг имен,
        если нужно соответствие не только по точному имени
    </li>
</ul>
Для упрощения идентификации шаблона в сгенерированный элемент добавляется CSS класс с именем <b>jianttm_&lt;имя шаблона&gt;</b>.
Например, для шаблона <b>tmTagView</b> это будет класс <b>jianttm_tmTagView</b>.
Это ускоряет поиск исходного кода при разработке.


<h4>Подстановка значений</h4>

Значения для подстановки имеют следующий формат:

<pre><code class="js">
    !!val!!
</code></pre>

Поддерживаются вложенные поля:

<pre><code class="js">
    !!obj.field1!!
    !!obj.field2!!
</code></pre>

Например:

<pre><code class="html">
    &lt;div>!!label!!&lt;/div>
    &lt;input name="!!data.name!!" value="!!data.value!!"/>
</code></pre>

Формат посвящен Терри Пратчетту, написавшему что количество восклицательных знаков пропорционально
умственной нестабильности субъекта. Таким образом, уравновешенный разработчик не будет использовать более одного
восклицательного знака подряд и два подряд можно смело использовать как маркер шаблона.

<h4>Безопасные шаблоны</h4>

Иногда специальные символы могут сломать разбор шаблона. Поэтому если нет стопроцентной уверенности в формате данных -
лучше использовать объявление элементов шаблона вместо <b>!!val!!</b> значений для подстановки.
Каждый вызов <b>parseTemplate()</b> также вызывает <b>propagate()</b>.
<p></p>
Следующие два фрагмента делают одно и то же:

<pre><code class="js">
    tm: {
        name: jiant.label
    }

    &lt;div id="_tm">
        &lt;div class="_name">&lt;/div>
    &lt;/div>
</code></pre>

<pre><code class="js">
    tm2: {
    }

    &lt;div id="_tm2">
        &lt;div>!!name!!&lt;/div>
    &lt;/div>
</code></pre>

Первый безопасней, второй не требует объявления элемента шаблона.
Также первый осуществляет проверку наличия необходимых элементов и обеспечивает лучшую документацию при изучении кода.
Также привязка к данным и прослушивание на предмет изменений возможно только при объявлении элементов в описании шаблона.
В общем случае первый вариант предпочтительней, но требует чуть больше кода в описании шаблона.

<h4>Объявление</h4>

Объявите шаблоны максимально абстрактно, не думая о реализации.
Шаблоны нужны чтобы генерировать динамическое содержимое интерфейса.
Вы можете объявлять элементы шаблонов так же как элементы виджетов.
Все эти элементы будут проверены на стадии связывания на предмет существования.
После разбора шаблона соответствующие поля будут привязаны к HTML элементам результата (к jQuery оберткам).
<p></p>
Пример

<pre><code class="js">
    templates: {

        tmTagView: {
            xCtl: jiant.ctl,
            dndCtl: jiant.ctl
        }

    }

    bindUi("_", app);
</code></pre>


<h4>Реализация</h4>

Добавьте HTML реализацию для каждого шаблона, привязывая шаблон по идентификатору и элементы по классам,
так же как виджеты. Подставляемые значения выделяются <b>!!</b> и обязательны при вызове шаблона.
Если объект с данными не включает это значение - будет сгенерирована ошибка.

<pre><code class="html">
    &lt;div id="_tmTagView" style="display:none;">
        &lt;div class="badge">
            &lt;a href="#" class="_xCtl">x&lt;/a>
            &lt;a class="_dndCtl">###&lt;/a>
            !!text!!
        &lt;/div>
    &lt;/div>
</code></pre>

<h4>Использование</h4>
После вызова функции <b>parseTemplate()</b> - возвращаемое значение это jQuery обертка,
которую можно использовать так же как любой виджет на странице. Все элементы из спецификации приложения связаны:

<pre><code class="js">
    var tagView = app.templates.tmTagView.parseTemplate({text: "some text"});
    app.views.main.tagsContainer.append(tagView);
    tagView.xCtl.click(function() {
        tagView.remove();
    });
</code></pre>


<h4>propagate</h4>

Каждый результат разбора шаблона получает функцию propagate, работающую в точности как для виджетов.
Смотрите <b>Виджеты</b> для деталей

<h4>Мета и CSS маркеры</h4>
Шаблоны поддерживают мета-маркеры и cssFlag / cssMarker, так же как виджеты. Смотрите <b>Виджеты</b> для деталей

<h4>Аналогия с виджетами</h4>
Вся функциональность виджетов доступна для шаблонов.
Прочитайте про виджеты, чтобы представлять что еще возможно делать с результатами разбора шаблонов.

<h4>Рецепты</h4>

поместите все шаблоны в один невидимый контейнер (div или i)
и поместите все <b>tr</b> шаблоны каждый в свой <b>tbody</b> в единой таблице:

<pre><code class="html">
    &lt;div style='display:none'>
        &lt;div id='_tm1'>
            &lt;div>!!val1!!&lt;/div>
        &lt;/div>
        &lt;div id='_tm2'>
            &lt;div>!!amount!!&lt;/div>
        &lt;/div>
    &lt;/div>

    &lt;table style='display:none'>
        &lt;tbody id='_tm3'>
        &lt;tr>
            &lt;td>!!name!!&lt;/td>
            &lt;td>!!email!!&lt;/td>
        &lt;/tr>
        &lt;/tbody>
    &lt;/table>
</code></pre>

<h4>Детали реализации</h4>

Стандартная практика в шаблонных движках - помещать шаблоны внутрь тэга <b>script</b>.
К сожалению в этом случае не будет DOM для содержимого
и будет невозможно проверить объявленные элементы шаблона на предмет наличия.
Поэтому только шаблоны без элементов могут быть помещены внуть тэга <b>script</b>:

<pre><code class="js">
    tmPrimitive: {}
</code></pre>

Как правило достаточно одного невидимого контейнера для всех нетабличных и одной таблицы для всех строковых шаблонов.
В случае <b>tr</b> - браузер автоматически генерирует <b>tbody</b>, поэтому нужно добавлять его руками,
как в данном примере:

<pre><code class="html">
    &lt;table style="display: none;">
        &lt;tbody id="_tmUpgradeRow">
        &lt;tr>
            &lt;td class="clickable">!!key!!&lt;/td>
            &lt;td class="_expAmount ra">!!value!!&lt;/td>
        &lt;/tr>
        &lt;/tbody>
        &lt;tbody id="_tmSkillRow">
        &lt;tr title='!!help!!'>
            &lt;td class='context_help'>!!key!!&lt;/td>
            &lt;td class="ra">!!value!!&lt;/td>
            &lt;td class="ra">!!cost!!&lt;/td>
            &lt;td class="_ctl clickable">+&lt;/td>
        &lt;/tr>
        &lt;/tbody>
    &lt;/table>
</code></pre>

Легко заметить принципиальное отличие от виджетов - контейнер не является частью шаблона. Поэтому когда смотрим
на виджеты - контейнер это уже сам виджет, а в случае шаблонов - его первый подэлемент есть результат разбора шаблона.
Поэтому шаблон всегда должен включать корневой элемент.
