<h4>Шина событий</h4>

Jiant обеспечивает встроенную шину событий (Event Bus, если вы пока не сталкивались с этим паттерном - посмотрите в интернете).
Чтобы использовать ее - добавьте секцию <b>events</b> в определение приложения и опишите ваши события уровня приложения:

<pre class="brush: js">
    var myApp = {

        .....

        events: {

            NewDataArrived: {
                fire: function(data) {},
                on: function(cb) {},
                off: function(handler) {}
            },

            NewPhoneCall: {
                fire: function(phoneNumber, operator) {},
                on: function(cb) {},
                off: function(handler) {}
            }

        }

    }
</pre>

во время биндинга приложения все методы будут автоматически реализованы Jiant'ом.
Теперь можно подписаться на события в одном месте и генерировать их в другом, все подписчики будут получать извещения о событиях.

<h4>Генерация событий</h4>

Где-нибудь в блоке <b>onUiBound</b>, используйте <b>fire</b> для генерации новых событий:

<pre class="brush: js">
    myApp.events.NewDataArrived.fire(myData);
    myApp.events.NewPhoneCall.fire("1234567890", "Johnny");
</pre>

<ul>
  <li>Подписчики начнут получать события только после своей регистрации на события</li>
  <li>Если нужно "запоминаемое" событие, возможно следует использовать семафор</li>
  <li>Любое количество подписчиков возможно и кто угодно может генерировать события</li>
</ul>

<h4>Подписка на события</h4>

Где-нибудь в блоке <b>onUiBound</b>, подпишитесь через метод <b>on</b>:

<pre class="brush: js">
    myApp.events.NewDataArrived.on(function(data) {
        //обрабатываем данные
    });

    myApp.events.NewPhoneCall.on(function(phoneNumber, operator) {
        //что-нибудь делаем
    });
</pre>

Вызов метода <b>on</b> возвращает хэндлер подписки, который затем можно использовать чтобы отписаться от события:

<pre class="brush: js">
    var h = myApp.events.NewDataArrived.on(function(data) {
        //обрабатываем данные
    });

    ...

    myApp.events.NewPhoneCall.off(h);
</pre>

<h4>Передача данных</h4>

Коллбэк метода <b>on</b> получает в точности все аргументы, переданные в метод <b>fire</b>.
Набор данных не зависит от объявленной сигнатуры метода fire и зависит только от переданных аргументов во время вызова.

<h4>Для ленивых</h4>

методы <b>fire</b>, <b>off</b> и <b>on</b> нужно определять только для целей автозавершения, документации и удобства.
Они всегда добавляются в событие, независимо от объявления.
Кратчайшая работающая форма описания шины событий следующая:

<pre class="brush: js">
    var myApp = {

        events: {
            NewDataArrived: {},
            NewPhoneCall: {}
        }

    }
</pre>

Однако не рекомендуется так писать, потому что неясно какие именно данные поступают когда событие случится.
С другой стороны, можно определить только метод fire, сэкономив на паре строк (on, off).

<h4>Детали реализации</h4>
Каждый объект события также содержит поле <b>listenersCount</b>, в котором хранится счетчик подписчиков.
Объект самого события сейчас не передается в метод <b>on</b>, поэтому параметры
коллбэка <b>on</b> в точности совпадают с параметрами метода <b>fire</b>