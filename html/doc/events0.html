<h4>Шина событий</h4>

Jiant обеспечивает встроенную шину событий (Event Bus, если вы пока не сталкивались с этим паттерном - посмотрите в интернете).
Чтобы использовать ее - добавьте секцию <b>events</b> в определение приложения и опишите ваши события уровня приложения:

<pre><code class="js">
    const myApp = {

        .....

        events: {

            NewDataArrived: {
                fire: function(data) {},
                on: function(cb) {},
                off: function(handler) {}
            },

            NewPhoneCall: {
                fire: function(phoneNumber, operator) {},
                on: function(cb) {},
                once: function(cb) {},
                off: function(handler) {}
            }

        }

    }
</code></pre>

во время биндинга приложения все методы будут автоматически реализованы Jiant'ом.
Теперь можно подписаться на события в одном месте и генерировать их в другом, все подписчики будут получать извещения о событиях.

<h4>Генерация событий</h4>

Где-нибудь в блоке <b>onApp</b>, используйте <b>fire</b> для генерации новых событий:

<pre><code class="js">
    myApp.events.NewDataArrived.fire(myData);
    myApp.events.NewPhoneCall.fire("1234567890", "Johnny");
</code></pre>

<ul>
  <li>Подписчики начнут получать события только после своей регистрации на события</li>
  <li>Если нужно "запоминаемое" событие, возможно следует использовать <a href="#jDocs=,semaphores,semaphores0,0">семафор</a></li>
  <li>Любое количество подписчиков возможно и кто угодно может генерировать события</li>
</ul>

<h4>Подписка на события</h4>

Где-нибудь в блоке <b>onApp</b>, подпишитесь через метод <b>on</b>:

<pre><code class="js">
    myApp.events.NewDataArrived.on(function(data) {
        //обрабатываем данные
    });

    myApp.events.NewPhoneCall.on(function(phoneNumber, operator) {
        //что-нибудь делаем
    });
</code></pre>

Вызов метода <b>on</b> возвращает хэндлер подписки, который затем можно использовать чтобы отписаться от события
через метод <b>off</b>. Вызов <b>off</b> без параметров отпишет все имеющиеся подписки.

<pre><code class="js">
    const h = myApp.events.NewDataArrived.on(function(data) {
        //обрабатываем данные
    });

    ...

    myApp.events.NewPhoneCall.off(h);
</code></pre>

Также доступен метод <b>once</b>, отличается от <b>on</b> тем, что выполняется только один раз и затем отписывается от события.

<h4>Передача данных</h4>

Коллбэк метода <b>on</b> получает в точности все аргументы, переданные в метод <b>fire</b>.
Набор данных не зависит от объявленной сигнатуры метода <b>fire</b> и зависит только от переданных аргументов во время вызова.

<h4>Для ленивых</h4>

методы <b>fire</b>, <b>off</b> и <b>on</b> нужно определять только для целей автозавершения, документации и удобства.
Они всегда добавляются в событие, независимо от объявления.
Кратчайшая работающая форма описания шины событий следующая:

<pre><code class="js">
    var myApp = {

        events: {
            NewDataArrived: {},
            NewPhoneCall: {}
        }

    }
</code></pre>

Однако не рекомендуется так писать, потому что неясно какие именно данные поступают когда событие случится.
С другой стороны, можно определить только метод fire, сэкономив на паре строк (on, off).

<h4>Приватные реализации</h4>
При связывании в рамках дерева, доступ к событиям имеет весь код приложения.
Если событие где-то используется локально (некий автобус местного назначения), его можно объявить и реализовать приватно.
Подробности <a href="#jDocs=,basics,basics_private,0,">здесь</a>.
В этом случае код отдельного модуля может вызвать метод <b>jiant.bindEvent</b>, как в примере кода:
<pre><code class="js">
    const event = jiant.bindEvent({
        fire: function(data),
        on: function(cb)
      });
    ...
    event.fire(myData);
</code></pre>
Реализованный метод готов к использованию после данного вызова, но не доступен из дерева приложения.
Для использования приватной реализации, необходимо добавить секцию events в дерево приложения, хотя бы пустую.
Пояснение <a href="#jDocs=,advanced,advanced_internal,0,">здесь</a>

<h4>Детали реализации</h4>
Каждый объект события также содержит поле <b>listenersCount</b>, в котором хранится счетчик подписчиков.
Объект самого события сейчас не передается в метод <b>on</b>, поэтому параметры
коллбэка <b>on</b> в точности совпадают с параметрами метода <b>fire</b>