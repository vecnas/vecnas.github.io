<h4>Состояния</h4>

Jiant.States обеспечивает поддержку хэш-навигации по истории в браузере и возможность сохранения состояния
приложения при обновлении страницы.
Например, когда вы хотите поддерживать кнопки вперед-назад в браузере или закладку на текущее состояние динамического аякс приложения
Чтобы начать использовать состояния - добавьте секцию <b>states</b> в определение приложения:

<pre><code class="js">
    var myApp = {

        ....

        states: {

            contactList: {
                go: function(pageNum, searchString) {},
                start: function(cb) {},
                end: function(cb) {},
                root: true
            },

            newContact: {
                go: function() {},
                replace: function() {},
                start: function(cb) {},
                end: function(cb) {}
            },

            editContact: {
                go: function(contactId) {},
                replace: function() {},
                start: function(cb) {},
                end: function(cb) {}
            }

        }

    }
</code></pre>

Теперь, в рамках функции <b>onUiBound</b>, для перехода в состояние <b>contactList</b>, можно вызвать:

<pre><code class="js">
    myApp.states.contactList.go(1, "");
    // теперь в хэш строке браузера вы увидите "#myApp=,contactList,1,|="
</code></pre>

Чтобы обрабатывать изменения состояния приложения - подпишитесь на события старта и завершения состояния
(как обычно, в рамках <b>onUiBound</b>):

<pre><code class="js">
    myApp.states.editContact.start(function(contactId) {
        myApp.views.loading.show();
        myApp.ajax.getContactData(contactId, function(contactData) {
            myApp.views.loading.hide();
            showEditContactForm(contactData);
        }
    });

    myApp.states.editContact.end(function(contactId) {
        hideEditContactForm();
    });
</code></pre>

<h4>Концептуальное отличие</h4>

Важнейшее отличие от всех известных мне систем хэш-навигации - это полное абстрагирование от собственно хэш-строки в браузере.
Jiant оперирует "состояниями" приложения. Внутренняя реализация сейчас сохраняет текущее состояние в хэш строку.
<p></p>
Другой важный момент - хэш-строка разделена между разными приложениями на одной странице и каждое имеет свое пространство имен в ней.
Поэтому можно использовать одинаковые имена переменных состояния, они не пересекутся.
Плюс навигация будет осуществляться раздельно для каждого состояния.


<h4>Функции и настройки состояний</h4>

Каждое состояние независимо от объявления получает 4 функции и может иметь следующие флаги/секции:

<pre><code class="js">
  someState: {
      go: function(params) {}, // функция перехода в состояние с записью в истории
      replace: function() {}, // функция перехода в состояние без записи в истории, заменой текущей хэш строки
      start: function(cb) {}, // регистрация коллбэка на переход в состояние
      end: function(cb) {}, // регистрация коллбэка на выход из состояния
      root: true, // флаг, если это корневое состояние
      jDefaults: {  // набор параметров состояний по умолчанию, имена совпадают с именами в объявлении функции go
          params: {a: 12, b: 15}
      }
  }
</code></pre>

Функция <b>replace</b> использует те же параметры, которые были объявлены в сигнатуре <b>go</b>

<h4>Параметры состояний</h4>

Состояние может иметь любое количество параметров. Пример последовательности событий состояний

<pre><code class="js">
    myApp.states.contactList.go(1);
        // fired contactList.start
    myApp.states.editContact.go(436);
        // fired contactList.end
        // fired editContact.start
    myApp.states.editContact.go(444);
        // fired editContact.start
    jiant.refreshState();
        // fired editContact.start
    myApp.states.newContact.go();
        // fired editContact.end
        // fired newContact.start
</code></pre>

Как правило коллбэки состояний получают те же параметры, которые были использованы при вызове <b>go()</b>.
Но передавая <b>undefined</b> как параметр вызова, вы можете переиспользовать последнее известное значение параметра.
Это полезно когда например меняется только один из параметров состояния, а другие остаются в прежних значениях.
Например:

<pre><code class="js">
    contactList.go(5, "s");
        // page num: 5, filter string: "s"
    contactList.go(undefined, "q");
        // page num still 5, filter string: "q"
    contactList.go(10);
        // page num: 10, filter string still "q"
        // but:
    newContact.go();
    contactList.go(10);
        // now filter string lost and resetted to empty value
</code></pre>

Что позволяет удобно разделить разные аспекты состояния.

<p></p>
<ul>
  <li>В качестве параметра состояния кроме очевидных строк и чисел можно передавать сложные объекты.</li>
  <li>При большом объеме данных - они могут не поместиться в хэш строку,
    поэтому необходимо заранее иметь в виду естественные ограничения браузера.</li>
</ul>

<h4>Значения по умолчанию</h4>
Для параметров состояний можно задать значения по умолчанию, они используются если значение не было передано
и нет унаследованного значения. Имена должны соответствовать объявленным именам в сигнатуре функции <b>go</b>

<pre><code class="js">

  states: {
      users: {
          go: function(pageNum) {},
          jDefaults: {
              pageNum: 1
          }
      }
  }

  ......

  app.states.users.go();
  // pageNum == 1
</code></pre>

<h4>Внешний скрипт</h4>

Движок состояний работает на основе <b>jquery.hashchange.js</b>, есть на github возле самого jiant.js.
Этот скрипт базируется на старом плагине к jQuery, дополнительно переработанном и адаптированном для jiant.
Если состояния используются, а плагин не добавлен - jiant показывает алерт

<pre><code class="js">
    No hashchange plugin and states configured. Don't use states or add $.hashchange plugin
</code></pre>

во время начального связывания (алерт если DEV_MODE включен, иначе просто ошибка в консоли)

<h4>Корневые состояния</h4>
Некоторые состояния приложения могут рассматриваться как корневые. Например, список контактов -
вы возвращаетесь сюда после редактирования контакта или создания нового. Такие состояния можно
отметить флагом <b>root</b>, как в примере выше.
После биндинга нужно вызвать

<pre><code class="js">
    jiant.goRoot(appId);
</code></pre>

в любой момент, чтобы вернуться к ближайшему корневому состоянию данного приложения.

Jiant всегда отслеживает последнее корневое состояние.

Например:
<pre><code class="js">
    myApp.states.contactList.go(2, "");
    myApp.states.contactList.go(5, "qwer");
    myApp.states.editContact.go(5643);
    // теперь пользователь нажимает "Save" и приложение вызывает
    jiant.goRoot();
    // пользователь оказался на 5 странице списка контактов с фильтром "qwer"
</code></pre>

Любое количество корневых состояний возможно. Вы всегда вернетесь к последнему со всеми его параметрами.

<h4>Пустое состояние</h4>

Для обработки начальной загрузки страницы, без хэш-строки, объявите пустое состояние:

<pre><code class="js">
    var myApp = {
        states: {
            "": {}
        }
    }
</code></pre>

Теперь вы можете прослушивать его как обычно:

<pre><code class="js">
    myApp.states[""].start(function() {
        goSomeDefaultState();
    });
</code></pre>

<h4>Обновление состояния</h4>

Чтобы заставить все подписчики состояния обновиться - вызовите <b>jiant.refreshState()</b>.
Полезно, например, когда вы удалили что-то со списка и хотите полностью перегрузить текущую страницу.
Этот метод также принимает идентификатор приложения чтобы обновить только одно приложение.

<pre><code class="js">
    jiant.refreshState(appId);
</code></pre>

<h4>Текущее состояние</h4>

Для получения текущего состояния (без параметров), можно использовать

<pre><code class="js">
    jiant.getCurrentState(appId);
</code></pre>

<h4>Внешний префикс для состояний</h4>

Если возникает необходимость задать другой урл в рамках состояния, можно воспользоваться
<pre><code class="js">
    app: {
        stateExternalBase = "http://another.server.com",
        .....
    }
</code></pre>
Если приложение определяет эту переменную, то она будет использоваться в качестве урла в навигации браузера вместо адреса текущей страницы.


<h4>Для ленивых</h4>

Можно объявлять состояния следующим образом:

<pre><code class="js">
    var myApp = {

    states: {
        contactList: {
            go: function(pageNum),
            root: true
        },
        newContact: {},
        editContact: {}
    }

    }
</code></pre>

Jiant добавит все необъявленные методы.

<h4>Несколько приложений</h4>
Движок состояний поддерживает несколько приложений на странице. Чтобы обновить только одно - вызовите
<b>jiant.refreshState</b> с параметром равным идентификатору приложения. Иначе будут обновлены
все приложения на странице.
        <p></p>
Пример - когда одно приложение является основным и загружает другое в какую-нибудь панель,
показываемую только при входе в некоторое состояние. Тогда при старте этого состояния иногда имеет смысл
для второго приложения вызвать обновление, например:

<pre><code class="js">
    mainApp.states.crmState.start(function() {
        jiant.refreshState(crmApp);
    });
</code></pre>


<h4>Детали реализации</h4>

Состояния хранятся в строке браузера. Как текущее, так и последнее корневое.
Корневое заменяется каждый раз, когда загружается какое-либо корневое состояние.