<h4>Идея</h4>

Многие программные решения выглядят похоже. Повторяя что-нибудь типа "поместить здесь постраничный список".
Теперь, благодаря Jiant, у нас есть действительно подходящий уровень абстракции приложения, чтобы мы могли
реализовать такие решения раз и навсегда. И только переиспользовать впоследствии.
Что-то вроде программирования шаблонами.
<p></p>
Например,

<pre><code class="js">
    pageableContentView(someContainerToPutData, someContainerForPager, itemRenderTemplate,
                        ajaxFunctionToGetDataFromServer, optionalExtraprocessorCallbackForItemExtraFunctionality)
        - программное решение для постраничного показа данных

    removeCtl(control, modelInstance)
        - элемент интерфейса для удаления объекта из модели
</code></pre>

Это выглядит как обычные функции, но более читаемо и понимаемо. Я называю их <b>eXtra Logic</b> (СверхЛогика).
<b>jiant_xl.js</b> содержит начальные рецепты и по мере понимания организации приложений - будет расширяться.
Все функции в нем базируются на высоком уровне абстракции, обеспечиваемом Jiant.

<h4>Важно</h4>

<b>Все XL функции возвращают функции, поэтому нужно их дополнительно вызвать, как в последующих примерах!</b>

<h4>Кнопка состояния</h4>

<b><pre><code class="js">
    ctl2state: function(ctl, state, selectedCssClass, goProxy)
</code></pre>
</b>

Переводит приложение в заданное состояние при взаимодействии пользователя с заданным элементом интерфейса.
<p></p>
Параметры
<ul>
    <li><b>ctl</b> кликабельный элемент</li>
    <li><b>state</b> состояние в которое нужно отправить</li>
    <li><b>selectedCssClass</b> [опционально] css класс, добавляемый к элементу, когда приложение в заданном состоянии</li>
    <li><b>goProxy</b> [опционально] прокси функция для случаев, когда просто вызвать <b>state.go()</b>
        недостаточно. Например, чтобы отправить приложение в состояние с параметрами.
        Состояние передается как параметр коллбэка: <b>goProxy(state)</b>
    </li>
</ul>

Пример

<pre><code class="js">
    jiant.xl.ctl2state(app.views.main.homeCtl, app.states.home, "active")()
</code></pre>

<h4>Состоятельные виджеты</h4>

<b><pre><code class="js">
    statefulViews: function(states, views)
</code></pre>
</b>

Виджеты чья видимость привязана к определенным состояниям приложения (слово состоятельный - в шутку).
Показывает данные виджеты при переходе в заданные состояния и прячет при выходе.
<p></p>
Параметры
<ul>
    <li><b>states</b> одно состояние или массив состояний</li>
    <li><b>views</b> виджет или массив виджетов</li>
</ul>

Пример
<pre><code class="js">
    jiant.xl.statefulViews(app.states.search, [app.views.searchPanel, app.views.searchResults])();
</code></pre>

<h4>Состоятельное приложение</h4>

<b><pre><code class="js">
    statefulApp: function(app, viewNameSuffix, defaultState)
</code></pre>
</b>

Используется для организации целого приложения в режиме поддержки состояний
- состояния и страницы к ним привязанные.
<p></p>
Параметры
<ul>
    <li><b>app</b> переменная определения приложения (обычно - 2й параметр для коллбэка <b>onUiBound(app, cb($, app))</b></li>
    <li><b>viewNameSuffix</b> суффикс который добавляется к имени состояния чтобы получить имя виджета который к нему привязан</li>
    <li><b>defaultState</b> [опционально] основное состояние - в которое необходимо перевести
        приложение сразу после загрузки, из пустого
    </li>
</ul>
Для каждого состояния приложения - ищет виджет с именем равным  имени состония плюс суффикс
и показывает-прячет его при входе-выходе из данного состояния.
Виджеты не прячутся на старте приложения, они реагируют только на изменения состояний.

<h4>Навигация приложения</h4>

<b><pre><code class="js">
    nav: function(app, view, suffix, selectedCssClass, goProxy)
</code></pre>
</b>

Используется для организации меню навигации приложения
<p></p>
Параметры
<ul>
    <li><b>app</b> переменная определения приложения, обычно 2й параметр коллбэка для onUiBound</li>
    <li><b>view</b> виджет, содержащий навигацию</li>
    <li><b>suffix</b> суффикс, добавляемый к состояниям для получения соответствующего элемента</li>
    <li><b>selectedCssClass</b> [опционально] css класс для подсветки элементов меню,
        когда приложение находится в соответствующем состоянии
    </li>
    <li><b>goProxy</b> [опционально] <b>state.go()</b> прокси функция, аналогично <b>ctl2state</b> выше</li>
</ul>
Для каждого состояния приложения ищет элемент внутри виджета навигации с именем равным состоянию плюс суффикс
и добавляет к нему обработчик перехода в данное состояние

<h4>Представление модели</h4>

<b><pre><code class="js">
    bindList: function(model, container, template, viewFieldSetterName)
</code></pre>
</b>

Представляет модель на интерфейсе. Отслеживает изменения модели, добавляя/удаляя и изменяя данные:
<p></p>
Параметры:
<ul>
    <li><b>model</b> модель, объявленная в определении приложения</li>
    <li><b>container</b> контейнер куда помещаются представления объектов модели</li>
    <li><b>template</b> шаблон для отрисовки отдельного объекта модели.
        Может быть функцией: <b>tm(obj)</b>, принимающей объект модели и возвращающей шаблон
        для отрисовки в зависимости от данных
    </li>
    <li><b>viewFieldSetterName</b> [опционально] имя метода модели для сохранения элемента представляющего объект</li>
</ul>

Пример:

<pre><code class="js">
    models: {
        user: {
            add: function(list) {},
            remove: function(obj) {},

            id: function(id) {},
            view: function(view) {}
        }
    }

    jiant.xl.bindList(app.models.user, app.views.userList, app.templates.userTm, "view")()
</code></pre>

<h4>Представление списка объектов</h4>

<b><pre><code class="js">
    renderList: function(list, container, tm, perItemCb, noItemsLabel)
</code></pre>
</b>

представляет список объектов на интерфейсе
<p></p>
Параметры:
<ul>
    <li><b>list</b> массив объектов</li>
    <li><b>container</b> контейнер для размещения элементов</li>
    <li><b>tm</b> шаблон для отрисовки отдельного объекта</li>
    <li><b>perItemCb</b> [опционально] коллбэк, вызывается для каждого объекта, принимает объект
        и сгенерированный элемент интерфейса - <b>perItemCb(obj, elem)</b></li>
    <li><b>noItemsLabel</b> [опционально] элемент для показа если список пуст, например ссылка на html div "нет контактов"</li>
</ul>

<h4>Кнопка сохранения</h4>

<b><pre><code class="js">
    saveCtl: function(ctl, saveFn, markerElem, markerText)
</code></pre>
</b>
Представляет собой некое поведение интерфейса - кнопка, меняющая внешний вид при выполнении действий
и возвращающая свой вид при их завершении. Также добавляет флаг disabled на кнопку во избежание двойных щелчков.
<p></p>
Параметры
<ul>
    <li><b>ctl</b> собственно сама кнопка или другой элемент интерфейса</li>
    <li><b>saveFn</b> функция, выполняющая действие. Например, аякс вызов на сервер, или другое действие</li>
    <li><b>markerElem</b> [опционально, по умолчанию: сама кнопка] элемент, визуально представляющий действие
        в процессе
    </li>
    <li><b>markerText</b> [опционально, по умолчанию: "saving"] текст, который
        показывается/прячется на маркере, пока действие в процессе
    </li>
</ul>

Пример
<pre><code class="js">
    jiant.xl.saveCtl(app.views.userForm.saveCtl, app.ajax.saveUser, app.views.userForm.saveCtl, "Saving ...")()
</code></pre>

<h4>Постраничное содержимое</h4>

<b><pre><code class="js">
    pagedContent: function(state, ajax, container, pager, template, perItemCb, noItemsLabel, onCompleteCb, useSorting)
</code></pre>
</b>

Отрисовывает содержимое постранично, предоставляет навигацию по страницам
<p></p>
Параметры:
<ul>
    <li><b>state</b> состояние приложения, отрисовка страницы происходит на начало состояния.
        Состояние должно принимать номер страницы как 1й параметр
    </li>
    <li><b>ajax</b> аякс или другая функция, возвращающая данные через коллбэк.
        Первый параметр функции будет <b>pageable</b>, последний - собственно коллбэк принимающий данные
        (см. пример ниже). Когда нужно передать дополнительные параметры на сервер - используйте
        прокси функцию (см. пример)
    </li>
    <li><b>container</b> контейнер для отрисовки данных, элемент виджета</li>
    <li><b>pager</b> [опционально] контейнер навигации по страницам. При объявлении объявите элемент как jiant.pager.
        Если нужно несколько пейджеров (например, над и под списком) - просто повесьте класс на оба div'а, так что
        элемент будет ссылаться на 2 HTML элемента
    </li>
    <li><b>template</b> шаблон для отрисовки отдельного объекта данных</li>
    <li><b>perItemCb</b> [опционально] коллбэк, вызывается для каждого элемента, <b>perItemCb(obj, elem)</b>
        - принимает объект данных и сгенерированную jQuery обертку HTML элемента
    </li>
    <li><b>noItemsLabel</b> [опционально] маркер, показываемый если список пуст (элемент виджета)</li>
    <li><b>onCompleteCb</b> [опционально] коллбэк, вызываемый когда весь список отрисован, принимает как параметр
        весь объект данных, который вернула функция получения данных
    </li>
    <li><b>useSorting</b> [опционально] добавлять ли сортировку к серверному вызову, в spring-совместимом виде</li>
</ul>

Пример
<pre><code class="js">
    jiant.xl.pagedContent(app.states.contactList, function(pageable, cb) {
            app.ajax.getContacts(selectedUserId, pageable,cb)
    }, app.views.contacts.container, app.views.contacts.pager,
    app.templates.contactTm, null, "no contacts for given user")();
</code></pre>

<h4>Пример</h4>

Некая кнопка, отсылающая приложение в определенное состояние:

<pre><code class="js">
    ctl2state: function(ctl, state, selectedCssClass) {
        return function() {
            ctl.click(function() {
                state.go();
            });
            selectedCssClass && state.start(function() {
                ctl.addClass(selectedCssClass);
            });
            selectedCssClass && state.end(function() {
                ctl.removeClass(selectedCssClass);
            });
        };
    }
</code></pre>

3 параметра:
<ul>
    <li>кнопка <b>ctl</b>, объявленная как некий элемент виджета</li>
    <li>состояние <b>state</b>, объявленное как некое состояние приложения</li>
    <li><b>selectedCssClass</b> - строка, css класс, добавляемый к кнопке когда приложение
        находится в заданном состоянии
    </li>
</ul>

Теперь используем:

<pre><code class="js">
    jiant.xl.ctl2state(footer.showActiveCtl, app.states.active, cls)();
    jiant.xl.ctl2state(footer.showCompletedCtl, app.states.completed, cls)();
    jiant.xl.ctl2state(footer.showAllCtl, app.states[""], cls)();
</code></pre>

Добавляем к приложению готовую логику любой сложности всего одной строкой

<h4>Светлое будущее</h4>

Каждый раз, разрабатывая какую-то концепцию - сохраняем ее для будущего использования
как некий eXtra Logic рецепт. В следующий раз вы получите больше готовой программной логики
вместо просто переписывания заново.
<p></p>
Это словно jQuery плагины, но не для визуальных компонентов, а для программных решений