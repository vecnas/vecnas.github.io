<h4>Начало</h4>

Чтобы использовать шаблоны, добавьте секцию <b>templates</b> в определение приложения:

<pre><code class="js">
    var app = {
        templates: {
            tmTagView: {},
            tmMenuItem: {}
        }
    }

    bindUi("_", app);
</code></pre>

используем:

<pre><code class="js">
    app.templates.tmTagView.parseTemplate({text: "some text"});
</code></pre>

<h4>Подстановка значений</h4>

Значения для подстановки имеют следующий формат:

<pre><code class="js">
    !!val!!
</code></pre>

Поддерживаются вложенные поля:

<pre><code class="js">
    !!obj.field1!!
    !!obj.field2!!
</code></pre>

Например:

<pre><code class="html">
    &lt;div>!!label!!&lt;/div>
    &lt;input name="!!data.name!!" value="!!data.value!!"/>
</code></pre>

Формат посвящен Терри Пратчетту, написавшему что количество восклицательных знаков пропорционально
умственной нестабильности субъекта. Таким образом. уравновешенный разработчик не будет использовать более одного
восклицательного знака подряд и два подряд можно смело использовать как маркер шаблона.

<h4>Безопасные шаблоны</h4>

Иногда специальные символы могут сломать разбор шаблона. Поэтому если нет стопроцентной уверенности в формате данных -
лучше использовать объявление элементов шаблона вместо <b>!!val!!</b> значений для подстановки.
Каждый вызов <b>parseTemplate()</b> также вызывает <b>propagate()</b>.
<p></p>
Следующие два фрагмента делают одно и то же:

<pre><code class="js">
    tm: {
        name: jiant.label
    }

    &lt;div id="_tm">
        &lt;div class="_name">&lt;/div>
    &lt;/div>
</code></pre>

<pre><code class="js">
    tm2: {
    }

    &lt;div id="_tm2">
        &lt;div>!!name!!&lt;/div>
    &lt;/div>
</code></pre>

Первый безопасней, второй не требует объявления элемента шаблона.
Какой использовать - зависит от данных и ленивости разработчика.

<h4>Объявление</h4>

Объявите шаблоны максимально абстрактно, не думая о реализации.
Шаблоны нужны чтобы генерировать динамическое содержимое интерфейса.
Вы можете объявлять элементы шаблонов так же как элементы виджетов.
Все эти элементы будут проверены на стадии связывания на предмет существования.
После разбора шаблона соответствующие поля будут привязаны к HTML элементам результата (к jQuery оберткам).
<p></p>
Пример

<pre><code class="js">
    templates: {

        tmTagView: {
            xCtl: jiant.ctl,
            dndCtl: jiant.ctl
        }

    }

    bindUi("_", app);
</code></pre>

<h4>Реализация</h4>

Добавьте HTML реализацию для каждого шаблона, привязывая шаблон по идентификатору и элементы по классам,
так же как виджеты. Подставляемые значения выделяются <b>!!</b> и обязательны при вызове шаблона.
Если объект с данными не включает это значение - будет сгенерирована ошибка. Это сделано чтобы передача параметров
выполнялась точно, чтобы заставить разработчика быть внимательным:

<pre><code class="html">
    &lt;div id="_tmTagView" style="display:none;">
        &lt;div class="badge">
            &lt;a href="#" class="_xCtl">x&lt;/a>
            &lt;a class="_dndCtl">###&lt;/a>
            !!text!!
        &lt;/div>
    &lt;/div>
</code></pre>

<h4>Использование</h4>
После вызова функции <b>parseTemplate()</b> - возвращенное значение это jQuery обертка,
которую можно использовать так же как любой виджет на странице. Все элементы из спецификации приложения связаны:

<pre><code class="js">
    var tagView = app.templates.tmTagView.parseTemplate({text: "some text"});
    app.views.main.tagsContainer.append(tagView);
    tagView.xCtl.click(function() {
        tagView.remove();
    });
</code></pre>

<h4>Propagate</h4>

Каждый результат разбора шаблона получает функцию propagate, работающую в точности как для виджетов.
Смотрите Виджеты для деталей

<h4>Мета маркеры</h4>
Шаблоны поддерживают мета-маркеры, так же как виджеты. Смотрите Виджеты для деталей

<h4>Рецепты</h4>

поместите все шаблоны в один невидимый контейнер (div или i)
и поместите все <b>tr</b> шаблоны каждый в свой <b>tbody</b> в единой таблице:

<pre><code class="html">
    &lt;div style='display:none'>
        &lt;div id='_tm1'>
            &lt;div>!!val1!!&lt;/div>
        &lt;/div>
        &lt;div id='_tm2'>
            &lt;div>!!amount!!&lt;/div>
        &lt;/div>
    &lt;/div>

    &lt;table style='display:none'>
        &lt;tbody id='_tm3'>
        &lt;tr>
            &lt;td>!!name!!&lt;/td>
            &lt;td>!!email!!&lt;/td>
        &lt;/tr>
        &lt;/tbody>
    &lt;/table>
</code></pre>

<h4>Детали реализации</h4>

Стандартная практика в шаблонных движках - помещать шаблоны внутрь тэга <b>script</b>.
К сожалению в этом случае не будет DOM для содержимого
и будет невозможно проверить объявленные элементы шаблона на предмет наличия.
Поэтому только шаблоны без элементов могут быть помещены внуть тэга <b>script</b>:

<pre><code class="js">
    tmPrimitive: {}
</code></pre>

Как правило достаточно одного невидимого контейнера для всех нетабличных и одной таблицы для всех строковых шаблонов.
В случае <b>tr</b> - браузер автоматически генерирует <b>tbody</b>, поэтому нужно добавлять его руками,
как в данном примере:

<pre><code class="html">
    &lt;table style="display: none;">
        &lt;tbody id="_tmUpgradeRow">
        &lt;tr>
            &lt;td class="clickable">!!key!!&lt;/td>
            &lt;td class="_expAmount ra">!!value!!&lt;/td>
        &lt;/tr>
        &lt;/tbody>
        &lt;tbody id="_tmSkillRow">
        &lt;tr title='!!help!!'>
            &lt;td class='context_help'>!!key!!&lt;/td>
            &lt;td class="ra">!!value!!&lt;/td>
            &lt;td class="ra">!!cost!!&lt;/td>
            &lt;td class="_ctl clickable">+&lt;/td>
        &lt;/tr>
        &lt;/tbody>
    &lt;/table>
</code></pre>

Легко заметить принципиальное отличие от виджетов - контейнер не является частью шаблона. Поэтому когда смотрим
на виджеты - контейнер это уже сам виджет, а в случае шаблонов - его первый подэлемент есть результат разбора шаблона.
Поэтому шаблон всегда должен включать корневой элемент.
