<h4>Начало</h4>

Иногда необходимо чтобы программная логика могла быть переиспользована по всему приложению.
Для таких случаев Jiant предлагает абстракцию программной логики и внешних модулей.
<p></p>
Объявите раздел <b>logic</b> в вашем определении, как описано далее.

<h4>Объявление</h4>

абстракция программной логики объявляется в секции <b>logic</b>:

<pre><code class="js">
    logic: {
        verifier: {
            checkField: function(field) {}
        },
        dataProcessor: {
            processData: function(data) {},
            processData2: function(data, anotherParam) {}
        }
    }
</code></pre>

раздел содержит набор интерфейсов, каждый содержит одну или несколько функций.
Эти интерфейсы есть абстракции программной логики.

<h4>Реализация</h4>

Во время связывания приложения каждая логика получает метод <b>implement()</b>, принимающий реализацию.
Теперь, если какой-то код реализует данную логику, он выполняет этот метод, передавая объект реализации:

<pre><code class="js">
    jiant.onUiBound(app, function($, app) {
        app.logic.verifier.implement({
            checkField: function(field) {
                // собственно реализация
            }
        });
    });
</code></pre>

<h4>Зависимости</h4>

Если какой-то код использует логику, он ее просто использует:

<pre><code class="js">
    app.logic.verifier.checkField(fld);
</code></pre>

Однако, что если реализация еще не загружена. Это возможно при использовании минификации кода,
когда порядок исполнения скриптов перемешан.
<p></p>
Чтобы избежать подобных проблем - достаточно объявить зависимость от логики
во время вызова <b>onUiBound()</b>:

<pre><code class="js">
    jiant.onUiBound(app, ["verifier"], function($, app) {});
</code></pre>

И этот код исполнится только после того как логика <b>verifier</b> будет реализована.

<h4>Обработка ошибок</h4>

Jiant поддерживает цепочки зависимостей логик, но некоторые неизбежно могут привести к тупику
из-за взаимной зависимости.
<p></p>
Например, код реализует логику А и зависит от Б, а другой код
реализует Б, но зависит от А. Такую цепочку невозможно разорвать.
<p></p>
Jiant предлагает 2 инструмента для того чтобы разработчик мог обнаружить такие проблемы:
<ul>
    <li><b>jiant.getAwaitingDepends()</b> функция возвращает список всех нереализованных
        логик на текущий момент, просто вызовите ее в консоли
    </li>
    <li>включите DEV_MODE, тогда если в течение 10 секунд после связывания приложения
        останутся нереализованные логики - ошибка будет напечата в консоль
    </li>
</ul>

Также во время выполнения <b>implement()</b> jiant проверяет что все объявленные методы реализованы
и печатает в консоль сообщения об отсутствующих.

<h4>Внешние модули</h4>

Когда программная логика совершенно не зависит от конкретного приложения и может использоваться в разных -
можно использовать Внешние модули.
<p></p>
Просто сделайте вызов в виде:

<pre><code class="js">
    jiant.declare("logicName", {
        verify: function(fld) {
            // собственно реализация
        }
    })
</code></pre>

и все зависимости от <b>logicName</b> будут разрешены. Если на странице несколько приложений
и только некоторые используют эту логику - она будет загружена только для них. Не следует хранить
специфичные для приложения данные внутри внешнего модуля, так как он может использоваться
одновременно для нескольких приложений.

<h4>Пример</h4>

Рассмотрим менеджер диалогов, которые могут показываться различными способами, в зависимости от окружения -
boostrap, jquery-ui, modalPopup. Мы можем обеспечить все три реализации логики "dialogs" и использовать нужную.
