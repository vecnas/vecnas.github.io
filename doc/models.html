<h4>Начало</h4>

Для использования jiant.models, добавьте секцию <b>models</b> в переменную определения приложения:

<pre><code class="js">
    models: {
        todo: {
            add: function(title, completed) {},
            remove: function(todo) {},
            all: function() {},
            findByCompleted: function(completed) {},

            completed: function(completed) {},
            title: function(title) {},
        }
    }
</code></pre>

Каждое определение модели содержит как методы работы с отдельными объектами модели,
так и методы для всей коллекции, как в примере выше

<h4>Объявление</h4>
Jiant автоматически реализует все объявленные методы, основываясь на их именах и сигнатурах.
Идея почерпнута из Spring CrudRepository интерфейса и применена к JScript.
Вы также можете написать собственную реализацию любого метода. Если метод не пустой -
Jiant не будет генерировать для него реализацию.

<h4>Методы над коллекциями</h4>
Следующие методы автоматически реализовываются, если объявлены в определении приложения.
Они должны вызываться как методы коллекций, т.е. от базовой модели, а не от конкретных объектов модели.

<pre><code class="js">
    var us = models.user.add(userData);
    models.user.remove(us); - правильно
    models.user.remove.on(cb) - правильно
    <strike>us.remove()</strike> - неверно
    <strike>us.remove.on(cb)</strike> - неверно
</code></pre>

<h6><b>addAll(arr)</b></h6>

добавляет в модель все объекты из переданного массива, привязывая поля к объявленным методам модели. Пример:

<pre><code class="js">
    models: {
        user : {
            addAll: function(arr) {},

            id: function(val) {},
            name: function(val) {},
        }
    }

    app.models.user.addAll([
        {id: 1, name: "Alexa"},
        {id: 2, name: "Benedictus"},
    ]);
</code></pre>

удобно использовать с серверными вызовами:

<pre><code class="js">
    app.ajax.getData(function(dataList) {
        app.models.data.addAll(dataList);
    });
</code></pre>

метод принимает как массив, так и отдельный объект
Чтобы добавить в коллекцию null (зачем бы) - нужно писать <b>addAll([null])</b>.
<b>addAll(null)</b> - не делает ничего

<h6><b>remove(obj)</b></h6>
удаляет переданный объект из модели, возвращает удаленный объект. Пример объявления выше.
Передавать нужно объект модели, например:

<pre><code class="js">
    models.user.remove(models.user.findById(12334));
</code></pre>

<h6><b>remove.on(callback)</b></h6>
подписчик на удаление объектов. Автоматически создается при объявлении метода <b>remove()</b>

<h6><b>updateAll(arr, removeMissing, matcherCb)</b></h6>
обновляет содержимое модели объектами переданного массива, используя <b>id()</b>
для идентификации объекта. Для каждого обновляемого объекта выполняется <b>update()</b>.
Для новых объектов выполняется <b>addAll()</b>, для удаляемых - <b>remove()</b>.
Поэтому все подписчики срабатывают как обычно, при этом подписки updateAll.on не существует.
<p></p>
Если <b>removeMissing</b> выставлено, то вызов <b>updateAll()</b> удаляет из коллекции элементы,
которых нет в переданном массиве. В случае если объект должен идентифицироваться не <b>id()</b>,
можно передать <b>matcherCb</b>, синтаксис - <b>matcherCb(obj1, obj2)</b>, возвращать <b>true</b>
для совпадающих объектов и <b>false</b> для разных.


<h6><b>all()</b></h6>
возвращает все объекты модели

<h6><b>listByFieldname(fieldValue)</b></h6>
ищет в коллекции объекты у которых поле <b>fieldname</b> (первая буква в нижнем регистре) равно переданному значению.
Например,

<pre><code class="js">
    listByCompleted(true);
</code></pre>

вернет все объекты у которых поле <b>completed</b> имеет значение <b>true</b>

<pre><code class="js">
    {
        ...
        completed: true,
        ...
    }
</code></pre>

<h6><b>findByFieldname(fieldValue)</b></h6>
то же самое что <b>listBy</b>, но возвращает одиночный элемент или <b>null</b>.
Удобный метод для поиска уникальных объектов, например <b>findById()</b>.
Если есть несколько объектов подходящих под условие, вернется первый попавшийся.

<h6><b>listByXXXAndYYY(xxx, yyy)</b></h6>
аналогично <b>listBy</b>, но выполняет поиск по нескольким полям, разделенным <b>And</b> -
любое количество полей поддерживается.

<h6><b>findByXXXAndYYYAndZZZ(xxx, yyy, zzz)</b></h6>
то же что выше, ищет один объект по набору значений полей

<h6><b>fieldname.on(cb)</b></h6>
подписка на изменение значения поля. <b>cb</b> - коллбэк функция, принимающая три параметра: сам объект модели,
новое значение поля, старое значение поля:

<pre><code class="js">
    сompleted.on(function(todo, completed, completedOld) {
       ....
    }
</code></pre>

возвращает специальный объект, который может использоваться для вызова <b>fieldname.off()</b>

<h6><b>fieldname.off(handlerHook)</b></h6>
убирает подписку на изменения поля

<pre><code class="js">
    var hook = completed.on();
    completed.off(hook);
</code></pre>

<h6><b>fieldname.asap(cb)</b></h6>
добавляет подписку на значение поля либо использует текущее значение, если оно установлено. Срабатывает только один раз.
<b>cb</b> - функция коллбэка, принимает два параметра - сам объект и значение поля:

<pre><code class="js">
    model.task.сompleted.asap(function(todo, completed) {
      ....
    }
</code></pre>

Подписки на поля можно выставлять на саму модель, чтобы получать извещения об изменении поля любого объекта, или
на каждый объект в отдельности, чтобы получать извещения только о данном объекте.

<h4>Методы над объектами</h4>

Следующие методы могут вызываться от конкретных объектов модели:

<h6><b>fieldname()</b></h6>
возвращает значение поля с именем <b>fieldname()</b>, как обычный геттер

<h6><b>fieldname(val)</b></h6>
устанавливает поле <b>fieldname()</b> в переданное значение, как обычный сеттер

<h6><b>asMap()</b></h6>
возвращает объект в виде JSON

<h6><b>update(obj, treatMissingAsNulls)</b></h6>
обновляет объект модели переданными данными. Если выставлен второй параметр
- все отсутствующие в <b>obj</b> поля будут выставлены в <b>null</b>, если не выставлен - сохранят старые значения

<h6><b>update.on(obj)</b></h6>
подписка на обновления объекта. Автоматически добавляется при объявлении update.
Вызывается при любом обновлении поля, а также при вызовах <b>updateAll()</b> и <b>addAll()</b>.
Событие происходит  после того как все поля выставлены в новые значения.

<h6><b>setXAndYAndZ(x, y, z)</b></h6>
выставляет все перечисленные поля, разделенные And и затем кидает событие обновления.
Для транзакционных обновлений нескольких полей зараз.

<h4>Реализация</h4>

Объекты модели хранятся в виде массивов, значения полей как свойства объектов.

<h4>Синглтон</h4>

Модель может использоваться как синглтон. В этом случае методы объектов вызываются от базовой модели:

<pre><code class="js">
    app.models.userSingleton.email("email@test.com");
</code></pre>

или в режиме объектов модели

<pre><code class="js">
    var instance1 = app.models.user.add({});
    instance1.email("email1@test.com");
    var instance2 = app.models.user.add({});
    instance2.email("email2@test.com");
    var whatIsIt = app.models.user.findById("email2@test.com");
</code></pre>

во втором случае все подписки на события синглтона также получат все обновления отдельных объектов,
поэтому лучше не смешивать эти два режима на одной модели.
Пример синглтона - окружение приложения.

<pre><code class="js">
    app.models.user.email.on(function(obj, val) {
        alert("!: " + val);
    });
    instance1.email.on(function(obj, val) {
        alert("1: " + val);
    });
    instance1.email("anotherEmail"); // 2 alerts
    instance2.email("anotherEmail"); // 1 alert
</code></pre>

<h4>Логгирование</h4>

Для каждого неясного определения функции в консоль печатается сообщение:
<pre><code class="js">
    Unsupported model functionality declaration, can't implement: functionName
</code></pre>

<h4>Пример</h4>

<pre><code class="js">
    var todo = app.models.todo.add(title, false);
    app.models.todo.add.on(updateView);
    app.models.todo.remove.on(updateView);
    app.models.todo.completed.on(updateView);
    var count = app.models.todo.listByCompleted(false).length;
    app.models.todo.add.on(function(todo) { ....
    $.each(app.models.todo.all(), function(idx, todo) {
        updateTodoView(todo);
    });
</code></pre>